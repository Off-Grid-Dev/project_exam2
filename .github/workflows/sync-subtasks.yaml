name: 'Sync sub-issues with parent'

on:
  issues:
    types: [opened, edited]
  workflow_dispatch:
    inputs:
      parent_issue_number:
        description: 'Parent issue number to sync (optional when running manually)'
        required: false
      overwrite_dates:
        description: 'If true, overwrite existing Start/Target lines in sub-issues (true|false)'
        required: false
        default: 'false'

permissions:
  issues: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Run sync script
        uses: actions/github-script@v6
        with:
          script: |
            const github = require('@actions/github');

            // Inputs
            const inputParent = core.getInput('parent_issue_number') || null;
            const overwriteDatesInput = core.getInput('overwrite_dates') || 'false';
            const overwriteDates = overwriteDatesInput.toLowerCase() === 'true';

            const context = github.context;
            const octokit = github.getOctokit(process.env.GITHUB_TOKEN);

            // Determine parent issue number:
            let parentIssueNumber = null;
            if (inputParent) {
              parentIssueNumber = parseInt(inputParent, 10);
            } else if (context.eventName === 'issues' && context.payload && context.payload.issue) {
              parentIssueNumber = context.payload.issue.number;
            } else {
              throw new Error('No parent issue number supplied and workflow not triggered by an issue event. Provide parent_issue_number input.');
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            core.info(`Parent issue number: ${parentIssueNumber}`);

            // Helper: fetch an issue
            async function fetchIssue(number) {
              const { data } = await octokit.rest.issues.get({
                owner,
                repo,
                issue_number: number,
              });
              return data;
            }

            // Helper: update an issue (milestone or body)
            async function updateIssue(number, params) {
              await octokit.rest.issues.update({
                owner,
                repo,
                issue_number: number,
                ...params,
              });
            }

            // Parse date lines from body
            function parseDatesFromBody(body) {
              if (!body) return {};
              const startMatch = body.match(/^\s*Start:\s*(\d{4}-\d{2}-\d{2})\s*$/im);
              const targetMatch = body.match(/^\s*Target:\s*(\d{4}-\d{2}-\d{2})\s*$/im);
              return {
                start: startMatch ? startMatch[1] : null,
                target: targetMatch ? targetMatch[1] : null,
              };
            }

            // Extract referenced issue numbers from a string (looks for #123 or owner/repo#123)
            function extractReferencedNumbers(text) {
              if (!text) return [];
              const issueNumbers = new Set();

              // Matches e.g. #123 or owner/repo#123
              const regex = /(?:[a-zA-Z0-9_.-]+\/[a-zA-Z0-9_.-]+)?#([0-9]+)/g;
              let m;
              while ((m = regex.exec(text)) !== null) {
                issueNumbers.add(parseInt(m[1], 10));
              }

              return Array.from(issueNumbers);
            }

            (async () => {
              try {
                const parent = await fetchIssue(parentIssueNumber);
                const parentMilestone = parent.milestone ? parent.milestone.number : null;

                core.info(`Parent milestone: ${parent.milestone ? parent.milestone.title : 'none'}`);

                const dates = parseDatesFromBody(parent.body || '');
                core.info(`Parsed parent dates: Start=${dates.start || 'none'} Target=${dates.target || 'none'}`);

                // Find children from parent body. You can change this logic if you prefer parsing checklists only.
                let children = extractReferencedNumbers(parent.body || '');
                // Remove parent itself if present
                children = children.filter(n => n !== parentIssueNumber);

                if (children.length === 0) {
                  core.info('No child issue references found in parent body.');
                  return;
                }

                core.info(`Found child issues: ${children.join(', ')}`);

                for (const childNumber of children) {
                  core.info(`-- Processing child #${childNumber}`);
                  const child = await fetchIssue(childNumber);

                  // Update milestone if parent has one and child doesn't match
                  if (parentMilestone && child.milestone && child.milestone.number === parentMilestone) {
                    core.info('   milestone already matches; skipping milestone update');
                  } else if (parentMilestone) {
                    core.info(`   setting milestone on #${childNumber} to ${parent.milestone.title}`);
                    await updateIssue(childNumber, { milestone: parentMilestone });
                  } else {
                    core.info('   parent has no milestone; skipping milestone update');
                  }

                  // Update Start/Target in child body
                  if (dates.start || dates.target) {
                    let childBody = child.body || '';

                    const childDates = parseDatesFromBody(childBody);

                    // Determine new lines, and whether to overwrite
                    const newLines = [];
                    if (dates.start) {
                      if (!childDates.start || overwriteDates) {
                        newLines.push(`Start: ${dates.start}`);
                      }
                    }
                    if (dates.target) {
                      if (!childDates.target || overwriteDates) {
                        newLines.push(`Target: ${dates.target}`);
                      }
                    }

                    if (newLines.length > 0) {
                      // Prepend the date lines at the top of the body for visibility.
                      // If there are existing Start/Target lines and overwriteDates=true, remove the old ones first.
                      if (overwriteDates) {
                        childBody = childBody.replace(/^\s*Start:\s*\d{4}-\d{2}-\d{2}\s*$/gim, '');
                        childBody = childBody.replace(/^\s*Target:\s*\d{4}-\d{2}-\d{2}\s*$/gim, '');
                        childBody = childBody.trimStart();
                      }

                      const newBody = `${newLines.join('\n')}\n\n${childBody}`;
                      core.info(`   updating body of #${childNumber} with lines:\n     ${newLines.join(' | ')}`);
                      await updateIssue(childNumber, { body: newBody });
                    } else {
                      core.info('   no date updates needed for this child (existing dates present and overwrite not set)');
                    }
                  } else {
                    core.info('   parent has no Start/Target dates; skipping date updates');
                  }
                }

                core.info('Sync complete.');
              } catch (err) {
                core.setFailed(err.message || String(err));
              }
            })();
